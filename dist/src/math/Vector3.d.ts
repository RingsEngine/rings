export declare class Vector3 {
    static readonly MAX: Vector3;
    static readonly MIN: Vector3;
    static readonly SAFE_MAX: Vector3;
    static readonly SAFE_MIN: Vector3;
    static readonly X_AXIS: Vector3;
    static readonly neg_X_AXIS: Vector3;
    static readonly Y_AXIS: Vector3;
    static readonly Z_AXIS: Vector3;
    static HELP_0: Vector3;
    static HELP_1: Vector3;
    static HELP_2: Vector3;
    static readonly EPSILON: number;
    static HELP_3: Vector3;
    static HELP_4: Vector3;
    static HELP_5: Vector3;
    static HELP_6: Vector3;
    static get ZERO(): Vector3;
    static get ONE(): Vector3;
    static get LEFT(): Vector3;
    static get RIGHT(): Vector3;
    static get UP(): Vector3;
    static get DOWN(): Vector3;
    static get BACK(): Vector3;
    static get FORWARD(): Vector3;
    x: number;
    y: number;
    z: number;
    w: number;
    index: number;
    private static _index;
    constructor(x?: number, y?: number, z?: number, w?: number);
    set a(value: number);
    set r(value: number);
    set g(value: number);
    set b(value: number);
    get a(): number;
    get r(): number;
    get g(): number;
    get b(): number;
    get length(): number;
    get lengthSquared(): number;
    get position(): this;
    static getTowPointbyDir(dir: Vector3, tp1: Vector3, tp2: Vector3, width: number, aix: Vector3): void;
    static pointToLine(point1: Vector3, point2: Vector3, position: Vector3): number;
    static dot(a: Vector3, b: Vector3): number;
    static getPoints(total: number, randSeed: number): any[];
    static getPointNumbers(total: number, randSeed: number): any[];
    static getAngle(from: Vector3, to: Vector3): number;
    static sqrMagnitude(arg0: Vector3): number;
    static getZYAngle(zd: Vector3, yd: Vector3): number;
    static sub(a: Vector3, b: Vector3, target?: Vector3): Vector3;
    static add(a: Vector3, b: Vector3, target?: Vector3): Vector3;
    static smoothDamp(current: Vector3, target: Vector3, currentVelocity: Vector3, smoothTime: number, maxSpeed: number, deltaTime: number): any;
    static distance(pt1: Vector3, pt2: Vector3): number;
    static squareDistance(pt1: Vector3, pt2: Vector3): number;
    static distanceXZ(pt1: Vector3, pt2: Vector3): number;
    set(x: number, y: number, z: number, w?: number): this;
    add(a: Vector3, target?: Vector3): Vector3;
    subVectors(a: Vector3, b: Vector3): this;
    addScalar(scalar: number): Vector3;
    subScalar(scalar: number): Vector3;
    min(v: Vector3, target?: Vector3): Vector3;
    max(v: Vector3, target?: Vector3): Vector3;
    distanceToSquared(v: Vector3): number;
    addXYZW(x: number, y: number, z: number, w: number, target?: Vector3): Vector3;
    clone(): Vector3;
    copyFrom(src: Vector3): Vector3;
    decrementBy(a: Vector3): void;
    dotProduct(a: Vector3): number;
    equals(toCompare: Vector3, allFour?: boolean): boolean;
    incrementBy(a: Vector3): void;
    divide(v: any): Vector3;
    negate(): this;
    normalize(thickness?: number): Vector3;
    applyQuaternion(q: any): this;
    applyMatrix4(m: any): Vector3;
    scaleBy(s: number): Vector3;
    mul(s: number): Vector3;
    scale(s: Vector3): Vector3;
    scaleToRef(s: number, ref: Vector3): Vector3;
    setTo(xa: number, ya: number, za: number, wa?: number): void;
    copy(src: Vector3): this;
    subtract(a: Vector3, target?: Vector3): Vector3;
    multiply(other: Vector3, target?: Vector3): Vector3;
    divided(other: Vector3, target?: Vector3): Vector3;
    div(v: number, target?: Vector3): Vector3;
    lerp(v0: Vector3, v1: Vector3, t: number): void;
    clamp(min: Vector3, max: Vector3): Vector3;
    toString(): string;
    normalizeToWay2D_XY(): void;
    toArray(): number[];
    copyToBytes(byte: DataView): void;
    crossProduct(a: Vector3, target?: Vector3): Vector3;
    crossVectors(a: Vector3, b: Vector3): this;
    multiplyScalar(scalar: number): this;
    setFromArray(array: number[], firstElementPos?: number): void;
    divideScalar(scalar: any): this;
    clampLength(min: number, max: number): this;
    setScalar(value: number): this;
    addScaledVector(v: Vector3, scale: number): Vector3;
    private static calAngle;
    static pointInsideTriangle(pt: Vector3, pt0: Vector3, pt1: Vector3, pt2: Vector3): boolean;
    private static pointInsideTriangle2d;
    private static productXY;
    static serialize(position: Vector3): Vector3;
}
